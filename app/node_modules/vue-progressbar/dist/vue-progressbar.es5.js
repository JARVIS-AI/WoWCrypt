'use strict';

var component = require('./vue-progressbar.vue');

var _vueProgressBar = _interopRequireDefault(component);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

//  default functions
const d_progressbar = function() {
  var p = {
    $root: null,
    state: {
      pTime: null,
      settings: null,
      timer: null,
      hideTimer: null,
      hideTimer2: null,
      revertTimer: null,
      cut: 0
    },
    log: function log(message) {
      return f_log(this, message);
    },
    init: function init(data) {
      return f_init(this, data);
    },
    start: function start(time) {
      this.$root.currentProgression++;
      return f_start(this, time);
    },
    set: function set(num) {
      return f_set(this, num);
    },
    get: function get() {
      return f_get(this);
    },
    increase: function increase(num) {
      return f_increase(this, num);
    },
    decrease: function decrease(num) {
      return f_decrease(this, num);
    },
    readyToRevert: function readyToRevert() {
      return f_readyToRevert(this);
    },
    revert: function revert() {
      return f_revert(this);
    },
    quickHide: function quickHide() {
      return f_quickHide(this);
    },
    hide: function hide() {
      return f_hide(this);
    },
    pause: function pause() {
      return f_pause(this);
    },
    finish: function finish() {
      return f_finish(this);
    },
    fail: function fail() {
      return f_fail(this);
    },
    callMeta: function callMeta() {
      var args = Array.prototype.slice.call(arguments)
      return f_callMeta(this, args);
    },
    callSetTemp: function callSetTemp() {
      var args = Array.prototype.slice.call(arguments)
      return f_callSetTemp(this, args);
    },
    callRevert: function callRevert(revert) {
      return f_callRevert(this, revert);
    },
    call: function call() {
      var args = Array.prototype.slice.call(arguments)
      return f_call(b, args);
    },
    parseMeta: function parseMeta(meta) {
      return f_parseMeta(this, meta);
    },
    randomize: function randomize(meta) {
      return f_randomize(this, meta);
    }
  };
  return p;
};
const d_bardata = function(options) {
  var d = {
    init: options.init !== undefined ? options.init : true,
    initiated: false,
    percent: 0,
    hidden: true,
    quickHide: false,
    quicklyHid: false,
    setupInverse: false,
    currentProgression: 0,
    temp: {
      rGradient: true,
      use: false,
      autoRevert: true,
      canSuccess: true,
      color: 'rgb(19, 91, 55)',
      debug: false,
      failedColor: 'red',
      inverse: false,
      location: 'top',
      show: false,
      thickness: '2px',
      trail: '-1px',
      transition: {
        time: '0.2s',
        opacity: '0.6s'
      }
    },
    options: {
      rGradient: options.rGradient !== undefined ? options.rGradient : true,
      autoRevert: options.autoRevert !== undefined ? options.autoRevert : true,
      canSuccess: true,
      color: options.color || 'rgb(19, 91, 55)',
      debug: options.debug || false,
      failedColor: options.failedColor || 'red',
      inverse: options.inverse || false,
      location: options.location || 'top',
      show: false,
      thickness: options.thickness || '2px',
      trail: options.trail || '-1px',
      transition: options.transition || {
        time: '0.2s',
        opacity: '0.6s'
      }
    }
  }
  return d;
}
//  generate functions
const g_progressBar = function g_progressBar() {
  var args = Array.prototype.slice.call(arguments)
  var name = args[0] !== null ? args[0] : null;
  var options = args[1] !== null ? args[1] : {};
  if (name === undefined) {
    name = g_rUUID('##-#');
  }
  return {reference: name, progress: d_progressbar(), data: d_bardata(options)};
};
//  generate random functions
const g_rUUID = function g_rUUID(seed) {
  var s4 = function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }
  var uuid = '';
  if (seed !== undefined) {
    for (var i = 0; i < seed.length; i++) {
      switch(seed.charAt(i)) {
        case '-':
          uuid += '-';
          break;
        default:
          uuid += s4();
          break;
      }
    }
  } else {
    uuid = s4()+'-'+s4();
  }
  return uuid;
}
const g_rIntInclusive = function(min, max) {
  min = Math.floor(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
const g_rColor = function(color) {
  var r = {min: 0, max: 255}, g = {min: 0, max: 255}, b = {min: 0, max: 255};
  if (color !== undefined) {
    if (color.r !== undefined) {
      color.r.min !== undefined ? r.min = color.r.min : null;
      color.r.max !== undefined ? r.max = color.r.max : null;
    }
    if (color.g !== undefined) {
      color.g.min !== undefined ? g.min = color.g.min : null;
      color.g.max !== undefined ? g.max = color.g.max : null;
    }
    if (color.b !== undefined) {
      color.b.min !== undefined ? b.min = color.b.min : null;
      color.b.max !== undefined ? b.max = color.b.max : null;
    }
  }
  return 'rgb('+g_rIntInclusive(r.min, r.max)+', '+g_rIntInclusive(g.min, g.max)+', '+g_rIntInclusive(b.min, b.max)+')';
}
const g_rThickness = function(thickness) {
  var min = 2, max = 7, suffix = 'px';
  if (thickness !== undefined) {
    thickness.min !== undefined ? min = thickness.min : null;
    thickness.max !== undefined ? max = thickness.max : null;
    thickness.suffix !== undefined ? suffix = thickness.suffix : null;
  }
  return g_rIntInclusive(min, max)+suffix;
}
const g_rTrail = function(trail) {
  var min = 50, max = 100, suffix = 'px';
  if (trail !== undefined) {
    trail.min !== undefined ? min = trail.min : null;
    trail.max !== undefined ? max = trail.max : null;
    trail.suffix !== undefined ? suffix = trail.suffix : null;
  }
  return g_rIntInclusive(min, max)+suffix;
}
const g_rTransition = function(transition) {
  var timeDec, opacityDec, timeInt, opacityInt, x;
  if (transition !== undefined) {
    if (transition.time.min !== undefined && transition.time.max !== undefined) {
      if (transition.time.min % 1 === 0 || transition.time.max % 1 === 0) {
        timeDec = 0;
      } else {
        timeDec = g_rIntInclusive(Math.floor((transition.time.min % 1)*100), Math.floor((transition.time.max % 1)*100));
      }
      timeInt = g_rIntInclusive(transition.time.min, transition.time.max);
    } else {
      timeInt = g_rIntInclusive(0, 1);
      timeInt < 1 ? timeDec = g_rIntInclusive(50, 99) : timeDec = g_rIntInclusive(0, 50);
    }
    if (transition.opacity.min !== undefined && transition.opacity.max !== undefined) {
      if (transition.opacity.min % 1 === 0 || transition.opacity.max % 1 === 0) {
        opacityDec = 0;
      } else {
        opacityDec = g_rIntInclusive(Math.floor((transition.opacity.min % 1)*100), Math.floor((transition.opacity.max % 1)*100));
      }
      opacityInt = g_rIntInclusive(transition.opacity.min, transition.opacity.max);
    } else {
      opacityInt = g_rIntInclusive(0, 1);
      opacityInt < 1 ? opacityDec = g_rIntInclusive(50, 99) : opacityDec = g_rIntInclusive(0, 50);
    }
  } else {
    timeInt = g_rIntInclusive(0, 1);
    opacityInt = g_rIntInclusive(0, 1);
    timeInt < 1 ? timeDec = g_rIntInclusive(50, 99) : timeDec = g_rIntInclusive(0, 50);
    opacityInt < 1 ? opacityDec = g_rIntInclusive(50, 99) : opacityDec = g_rIntInclusive(0, 50);
  }
  x = {time: timeInt+'.'+timeDec+'s', opacity: opacityInt+'.'+opacityDec+'s'};
  return x;
}
const g_rLocation = function(location) {
  if (location !== undefined) {
    return location[g_rIntInclusive(0, location.length-1)]
  } else {
    switch(g_rIntInclusive(0, 3)) {
      case 0:
        return 'top';
      case 1:
        return 'bottom';
      case 2:
        return 'left';
      case 3:
        return 'right';
    }
  }
}
const g_rInverse = function(inverse) {
  if (inverse !== undefined) {
    return inverse[g_rIntInclusive(0, inverse.length-1)];
  } else {
    switch(g_rIntInclusive(0, 1)) {
      case 0:
        return false;
      case 1:
        return true;
    }
  }
}
//  regex constants
const r_regexColor = new RegExp("(^#[0-9a-fA-F]{6}$)|(^#[0-9a-fA-F]{3}$)|(^rgb\\([0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}\\)$)");
const r_regexLocation = new RegExp("(left|right|top|bottom)");
const r_regexTime = new RegExp("(\\d+\\.\\d+)(s|ms)|(\\.\\d+)(s|ms)|(\\d+)(s|ms)");
const r_regexThickness = new RegExp("(\\d+\\.\\d+)(px|em|pt|%|vh|vw)|(\\.\\d+)(px|em|pt|%|vh|vw)|(\\d+)(px|em|pt|%|vh|vw)");
const r_regexTrail = new RegExp("(\\d+\\.\\d+)(px|em|pt|%|vh|vw)|(\\.\\d+)(px|em|pt|%|vh|vw)|(\\d+)(px|em|pt|%|vh|vw)");
//  helper functions
const h_validColor = function h_validColor(color) {
  return r_regexColor.test(color);
};
const h_validLocation = function h_validLocation(location) {
  return r_regexLocation.test(location);
};
const h_validTime = function h_validTime(time) {
  return r_regexTime.test(time);
};
const h_validThickness = function h_validThickness(thickness) {
  return r_regexThickness.test(thickness);
};
const h_validTrail = function h_validTrail(trail) {
  return r_regexTrail.test(trail);
};
const h_validate = function h_validate() {
  var args = Array.prototype.slice.call(arguments)
  if (args !== undefined && args[0] !== undefined && args[1] !== undefined) {
    switch (args[0]) {
      case 'color':
        return h_validColor(args[1]);
      case 'fail':
        return h_validColor(args[1]);
      case 'location':
        return h_validLocation(args[1]);
      case 'time':
        return h_validTime(args[1]);
      case 'thickness':
        return h_validThickness(args[1]);
      case 'trail':
        return h_validTrail(args[1]);
      case 'inverse':
        return typeof args[1] === 'boolean'
      case 'transition':
        return (h_validTime(args[1].time) && h_validTime(args[1].opacity));
    }
  } else {
    console.log(args);
    var caller_line = (new Error).stack.split("\n")[4];
    console.log('not enough arguments: ' + caller_line);
  }
};
const h_setFailColor = function h_setFailColor(b, color, temp) {
  if (temp) {
    b.$root.temp.failedColor = color;
    !b.$root.temp.use ? b.$root.temp.use = true : null;
  } else {
    b.$root.options.failedColor = color;
  }
};
const h_setColor = function h_setColor(b, color, temp) {
  if (temp) {
    b.$root.temp.color = color;
    !b.$root.temp.use ? b.$root.temp.use = true : null;
  } else {
    b.$root.options.color = color;
  }
};
const h_setLocation = function h_setLocation(b, loc, temp) {
  if (temp) {
    b.$root.temp.location = loc;
    !b.$root.temp.use ? b.$root.temp.use = true : null;
  } else {
    b.$root.options.location = loc;
  }
};
const h_setTransition = function h_setTransition(b, transition, temp) {
  if (temp) {
    b.$root.temp.transition = transition;
    !b.$root.temp.use ? b.$root.temp.use = true : null;
  } else {
    b.$root.options.transition = transition;
  }
};
const h_setInverse = function h_setInverse(b, inverse, temp) {
  if (temp) {
    b.$root.temp.inverse = inverse;
    !b.$root.temp.use ? b.$root.temp.use = true : null;
  } else {
    b.$root.options.inverse = inverse;
  }
};
const h_setThickness = function h_setThickness(b, thickness, temp) {
  if (temp) {
    b.$root.temp.thickness = thickness;
    !b.$root.temp.use ? b.$root.temp.use = true : null;
  } else {
    b.$root.options.thickness = thickness;
  }
};
const h_setTrail = function h_setTrail(b, trail, temp) {
  if (temp) {
    b.$root.temp.trail = trail;
    !b.$root.temp.use ? b.$root.temp.use = true : null;
  } else {
    b.$root.options.trail = trail;
  }
};
const h_set = function h_set(b) {
  var args = Array.prototype.slice.call(arguments);
  args[1] === 'color' ? h_setColor(b, args[2], args[3]): null;
  args[1] === 'fail' ? h_setFailColor(b, args[2], args[3]): null;
  args[1] === 'location' ? h_setLocation(b, args[2], args[3]): null;
  args[1] === 'transition' ? h_setTransition(b, {time: args[2].time, opacity: args[2].opacity}, args[3]): null;
  args[1] === 'inverse' ? h_setInverse(b, args[2], args[3]): null;
  args[1] === 'thickness' ? h_setThickness(b, args[2], args[3]): null;
  args[1] === 'trail' ? h_setTrail(b, args[2], args[3]): null;
};
//  progress functions
const f_log = function f_log(b, message) {
  if (b.state.settings.debug) {
    console.log(message);
  }
};
const f_init = function f_init(b, data) {
  b.$root = data;
  b.state.settings = b.$root.options;
  b.$root.initiated = true;
};
const f_start = function f_start(b, time) {
  b.$root.temp.use ? b.state.settings = b.$root.temp : b.state.settings = b.$root.options;
  if (!time) {
    if (h_validate('time', b.state.settings.transition.time)) {
      b.state.pTime = parseFloat(b.state.settings.transition.time.replace('/(ms|s)/'));
      if (!b.state.settings.transition.time.includes('ms')) {
        b.state.pTime *= 1000;
      }
      time = b.state.pTime;
    } else {
      f_log(b, 'invalid time: ' + b.state.settings.transition.time);
      f_log(b, 'valid formats: ##, #.#, .# [ms|s]');
      f_log(b, 'example: 1000ms, 1.0s, .10ms');
      b.state.pTime = time = 3000;
    }
  }
  if (!b.$root) return;
  b.$root.hidden = false;
  b.state.settings.show = true;
  b.state.settings.canSuccess = true;
  b.state.cut = 10000 / Math.floor(time);
  b.state.timer = setInterval(function() {
    f_increase(b, b.state.cut * Math.random());
    if (b.$root.percent > 95) {
      f_finish(b);
    }
  }, 100);
}
const f_set =  function f_set(b, num) {
  b.state.settings.show = true;
  b.state.settings.canSuccess = true;
  b.$root.percent = Math.floor(num);
};
const f_get = function f_get(b) {
  return Math.floor(b.$root.percent);
};
const f_increase = function f_increase(b, num) {
  b.$root.percent = b.$root.percent + Math.floor(num);
};
const f_decrease = function f_decrease(b, num) {
  b.$root.percent = b.$root.percent - Math.floor(num);
};
const f_readyToRevert = function f_readyToRevert(b) {
  if (b.$root.hidden) {
    f_revert(b);
  } else {
    b.state.revertTimer = setTimeout(function() {
      f_readyToRevert(b);
    }, 500);
  }
};
const f_revert = function f_revert(b) {
  b.$root.temp = {
    use: false,
    debug: b.$root.options.debug,
    canSuccess: b.$root.options.canSuccess,
    show: b.$root.options.show,
    color: b.$root.options.color,
    failedColor: b.$root.options.failedColor,
    thickness: b.$root.options.thickness,
    autoRevert: b.$root.options.autoRevert,
    location: b.$root.options.location,
    inverse: b.$root.options.inverse,
    transition: b.$root.options.transition,
    trail: b.$root.options.trail
  };
};
const f_quickHide = function f_quickHide(b) {
  if (b.$root.hidden) return false;
  b.$root.quickHide = true;
  b.$root.percent = 0;
  clearInterval(b.state.timer);
  clearTimeout(b.state.hideTimer);
  clearTimeout(b.state.hideTimer2);
  b.state.timer = null;
  if (b.state.settings.autoRevert && b.$root.temp.use) {
    clearTimeout(b.state.revertTimer);
    f_revert(b);
  }
  return true;
};
const f_hide = function f_hide(b) {
  clearInterval(b.state.timer);
  b.state.timer = null;
  if (b.state.settings.autoRevert && b.$root.temp.use) {
    f_readyToRevert(b);
  }
  b.state.hideTimer = setTimeout(function() {
    b.$root.options.show = false;
    b.$root.percent = 0;
    f_log(b, '1');
    b.state.hideTimer2 = setTimeout(function() {
      f_log(b, '2');
      b.$root.hidden = true;
    }, b.state.pTime);
  }, b.state.pTime);
};
const f_pause = function f_pause(b) {
  clearInterval(b.state.timer);
};
const f_finish = function f_finish(b) {
  if (!b.$root) return;
  b.$root.percent = 100;
  f_hide(b);
};
const f_fail = function f_fail(b, customColor) {
  b.state.settings.canSuccess = false;
  b.$root.percent = 100;
  f_hide(b);
};
const f_callMeta = function f_callMeta(b) {
  var args = Array.prototype.slice.call(arguments)
  f_call(b, 'set', args[1], args[3], args[2] === 'temp');
};
const f_callSetTemp = function f_callSetTemp(b) {
  var args = Array.prototype.slice.call(arguments)
  if (args[1] !== undefined && args[2] !== undefined && args[3] !== undefined) {
      h_validate(args[1], args[2]) ? h_set(b, args[1], args[2], args[3]) : f_log(b, 'invalid \'' + args[1] + '\' input: \"' + args[2] + '\"');
  }
};
const f_callRevert = function f_callRevert(b, revert) {
  h_set(b, revert, b.$root.options.color, true)
};
const f_call = function f_call(b) {
  var args = Array.prototype.slice.call(arguments)
  var temp;
  ((args[1] === 'temp' || args[1] === 'set') && args[4] !== undefined) ? temp = args[4] : temp = null;
  switch(args[1]) {
    case 'meta':
      f_callMeta(b, args[2], args[3], args[4]);
      break;
    case 'temp':
      if (temp === null) temp = true;
      f_callSetTemp(b, args[2], args[3], temp);
      break;
    case 'set':
      if (temp === null) temp = false;
      f_callSetTemp(b, args[2], args[3], temp);
      break;
    case 'revert':
      f_callRevert(b, args[2]);
      break;
  }
};
const f_parseMeta = function parseMeta(b, meta) {
  for (var x in meta.func) {
    f_call(b, 'meta', meta.func[x].call, meta.func[x].modifier, meta.func[x].argument);
  }
};
const f_randomize = function randomize(b, meta) {
  var data = { color: null, fail: null, thickness: null, location: null, inverse: null, transition: null};
  (meta !== undefined && meta.color !== undefined) ? data.color = g_rColor(meta.color) : data.color = g_rColor();
  (meta !== undefined && meta.fail !== undefined) ? data.fail = g_rColor(meta.fail) : data.fail = g_rColor();
  (meta !== undefined && meta.thickness !== undefined) ? data.thickness = g_rThickness(meta.thickness) : data.thickness = g_rThickness();
  (meta !== undefined && meta.location !== undefined) ? data.location = g_rLocation(meta.location) : data.location = g_rLocation() ;
  (meta !== undefined && meta.inverse !== undefined) ? data.inverse = g_rInverse(meta.inverse) : data.inverse = g_rInverse();
  (meta !== undefined && meta.transition !== undefined) ? data.transition = g_rTransition(meta.transition) : data.transition = g_rTransition();
  (meta !== undefined && meta.trail !== undefined) ? data.trail = g_rTrail(meta.trail) : data.trail = g_rTrail();
  var unparsed = {
    func: [
      {call: 'color', modifier: 'temp', argument: data.color},
      {call: 'fail', modifier: 'temp', argument: data.fail},
      {call: 'thickness', modifier: 'temp', argument: data.thickness},
      {call: 'location', modifier: 'temp', argument: data.location},
      {call: 'inverse', modifier: 'temp', argument: data.inverse},
      {call: 'transition', modifier: 'temp', argument: data.transition},
      {call: 'trail', modifier: 'temp', argument: data.trail}
    ]
  };
  f_parseMeta(b, unparsed);
};

const install = function install(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (Vue.version.split('.')[0] !== '2') {
    console.error('[ProgressBar] VueJS: out of date. \'v'+Vue.version+'\' of Vue is not supported. Please update to \'v2.x\'');
    return;
  } else {
    console.log('[ProgressBar] VueJS: version valid.')
  }
  var inBrowser = typeof window !== 'undefined';
  //  lets generate a default progress bar to work with
  //  add our array of progress bars to the event bus
  var array = [];

  var ProgressBarBus = new Vue({
    data: {
      bars: array
    },
    methods: {
      init: function init(bar) {
        if (!bar.data.initiated) {
          bar.progress.init(bar.data)
          console.log('[ProgressBar-'+bar.reference+'] initialized.')
        } else {
          console.log('[ProgressBar-'+bar.reference+'] already initialized.')
        }
      },
      get: function get(name) {
        for(var i = 0; i < this.bars.length; i++) {
          if (this.bars[i].reference === name) {
            return this.bars[i];
          }
        }
        return null;
      },
      add: function add(bar) {
        if (this.get(bar.reference) === null) {
          this.bars.push(bar)
          console.log('[ProgressBar-'+bar.reference+'] added.');
          if (bar.data.init) {
            if (!bar.data.initialized) {
              this.init(bar)
            } else {
              console.log('[ProgressBar-'+bar.reference+'] initialization already completed.')
            }
          } else {
            console.log('[ProgressBar-'+bar.reference+'] initialization must be done manually.')
          }
        } else {
          console.error('[ProgressBar] progress bar already registered under that name: \'' + bar.reference + '\'');
        }
      },
      create: function create(name, options) {
        if (this.get(name) !== null) {
          console.error('[ProgressBar] progress bar already registered under that name: \'' + name + '\'');
          return;
        }
        var options = options !== undefined ? options : {};
        var bar = {reference: name, progress: d_progressbar(), data: d_bardata(options)};
        this.add(bar)
      }
    }
  });
  //  setup our vue-component
  Vue.component('vue-progress-bar', _vueProgressBar.default);
  //
  Vue.prototype.$pb = ProgressBarBus;
};

module.exports = {
  install: install
};
